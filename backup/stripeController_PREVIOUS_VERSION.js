// =====================================
// CONTROLLER STRIPE POUR SOUNDORA
// =====================================
// G√®re les paiements via Stripe Checkout
//
// FONCTIONNALIT√âS INCLUSES :
// - Cr√©ation de sessions de paiement Stripe √† partir du panier
// - Gestion des webhooks pour confirmer les paiements
// - V√©rification du statut des sessions
// - Routes de test pour le d√©veloppement
//
// S√âCURIT√â :
// - Validation des donn√©es re√ßues
// - V√©rification des signatures webhook
// - Gestion d'erreurs robuste
// =====================================

import Stripe from "stripe";
import supabase from "../config/supabase.js"; // CORRECTION : Import par d√©faut au lieu d'import nomm√©

// Initialisation de Stripe avec la cl√© secr√®te depuis .env
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

/**
 * =============================================
 * CR√âATION D'UNE SESSION CHECKOUT STRIPE
 * =============================================
 *
 * R√îLE : Transforme le panier Soundora en session de paiement Stripe
 *
 * PROCESSUS :
 * 1. Validation des donn√©es re√ßues (panier + email)
 * 2. Conversion des articles Soundora au format Stripe
 * 3. Calcul du total de la commande
 * 4. Cr√©ation de la session Stripe avec configuration compl√®te
 * 5. Retour de l'URL de paiement au frontend
 *
 * S√âCURIT√â :
 * - Route prot√©g√©e par authentification Supabase
 * - Validation stricte des donn√©es re√ßues
 * - Gestion d'erreurs d√©taill√©e selon le type d'erreur Stripe
 *
 * @param {Object} req - Requ√™te Express avec cartItems et userEmail
 * @param {Object} res - R√©ponse Express
 */
export const createCheckoutSession = async (req, res) => {
  try {
    // ==========================================
    // √âTAPE 1 : EXTRACTION DES DONN√âES DE LA REQU√äTE
    // ==========================================
    const { cartItems, userEmail } = req.body;

    console.log("üõí Cr√©ation session Stripe pour:", userEmail);
    console.log("üì¶ Nombre d'articles:", cartItems?.length || 0);

    // ==========================================
    // √âTAPE 2 : VALIDATION DES DONN√âES RE√áUES
    // ==========================================

    // VALIDATION DU PANIER - S√âCURIT√â CRITIQUE üîí
    // Cette v√©rification emp√™che la cr√©ation de sessions Stripe vides ou malform√©es
    // !cartItems : V√©rifie que la propri√©t√© existe (pas undefined/null)
    // !Array.isArray(cartItems) : S'assure que c'est bien un tableau (pas un objet ou string)
    // cartItems.length === 0 : Emp√™che les paniers vides de cr√©er des sessions
    // ‚ö†Ô∏è SANS CETTE VALIDATION : Stripe g√©n√©rerait une erreur 400 c√¥t√© serveur
    if (!cartItems || !Array.isArray(cartItems) || cartItems.length === 0) {
      return res.status(400).json({
        success: false,
        error: "Le panier est vide ou invalide", // Message utilisateur friendly
      });
    }

    // VALIDATION EMAIL UTILISATEUR - OBLIGATOIRE POUR STRIPE üìß
    // Stripe Checkout n√©cessite un email pour :
    // 1. Pr√©-remplir le formulaire de paiement
    // 2. Envoyer le re√ßu de paiement automatiquement
    // 3. Identifier le client dans le dashboard Stripe
    // 4. Cr√©er la commande dans Supabase avec l'email correct
    if (!userEmail) {
      return res.status(400).json({
        success: false,
        error: "Email utilisateur requis", // Emp√™che les sessions anonymes
      });
    }

    // ==========================================
    // √âTAPE 3 : CONVERSION PANIER SOUNDORA ‚Üí FORMAT STRIPE
    // ==========================================

    // TRANSFORMATION CRITIQUE : SOUNDORA DATA ‚Üí STRIPE LINE_ITEMS üîÑ
    // Chaque article du panier Soundora doit √™tre converti au format attendu par Stripe
    // Cette √©tape est CRUCIALE car Stripe ne comprend que son propre format de donn√©es
    const lineItems = cartItems.map((item) => {
      // VALIDATION INDIVIDUELLE DE CHAQUE ARTICLE üõ°Ô∏è
      // V√©rification que chaque produit a les propri√©t√©s minimales requises
      // item.name : Nom du produit (obligatoire pour l'affichage Stripe)
      // item.price : Prix unitaire (obligatoire pour le calcul total)
      // ‚ö†Ô∏è SANS CES DONN√âES : L'API Stripe retournerait une erreur 400
      if (!item.name || !item.price) {
        throw new Error(`Article invalide: ${JSON.stringify(item)}`);
      }

      // CONSTRUCTION DE L'OBJET STRIPE LINE_ITEM üèóÔ∏è
      // Structure exacte attendue par l'API Stripe Checkout Sessions
      return {
        price_data: {
          // DEVISE EUROP√âENNE - Configuration r√©gionale üá™üá∫
          currency: "eur", // Devise europ√©enne pour le march√© fran√ßais de Soundora

          product_data: {
            // CONSTRUCTION DU NOM PRODUIT COMPLET üè∑Ô∏è
            // Combine la marque + nom pour un affichage professionnel
            // Exemple : "Gibson" + "Les Paul Studio" = "Gibson Les Paul Studio"
            // .trim() supprime les espaces en trop si marque manquante
            name: `${item.brands?.name || ""} ${item.name}`.trim(),

            // DESCRIPTION AVEC FALLBACK EN CASCADE üìù
            // Priorit√© : short_description > description > texte par d√©faut
            // Assure qu'il y a toujours une description, m√™me minimale
            description:
              item.short_description || // Description courte (priorit√© 1)
              item.description || // Description compl√®te (priorit√© 2)
              "Instrument de musique", // Fallback g√©n√©rique (priorit√© 3)

            // GESTION DES IMAGES PRODUIT üñºÔ∏è
            // Stripe accepte un tableau d'URLs d'images
            // [0] = premi√®re image du produit Soundora
            // Fallback sur image par d√©faut si pas d'image disponible
            images: [item.images?.[0] || "/assets/images/no-image.jpg"],

            // M√âTADONN√âES SOUNDORA ‚Üí STRIPE üìä
            // Ces donn√©es permettent la r√©conciliation entre Stripe et Supabase
            // Conserv√©es lors du webhook pour recr√©er la commande compl√®te
            metadata: {
              product_id: item.id || "", // ID produit Soundora (pour lien Supabase)
              sku: item.sku || "", // R√©f√©rence produit (gestion stock)
              category: item.categories?.name || "", // Cat√©gorie musicale (guitares, batteries...)
              brand: item.brands?.name || "", // Marque de l'instrument (Gibson, Fender...)
            },
          },

          // CONVERSION PRIX CRITIQUE : EUROS ‚Üí CENTIMES üí∞
          // ‚ö†Ô∏è IMPORTANT : Stripe travaille UNIQUEMENT en centimes !
          // Exemples : 1299‚Ç¨ ‚Üí 129900 centimes, 49.99‚Ç¨ ‚Üí 4999 centimes
          // Math.round() √©vite les erreurs d'arrondis JavaScript (ex: 49.99 * 100 = 4998.999...)
          unit_amount: Math.round(item.price * 100),
        },

        // QUANTIT√â DE CET ARTICLE DANS LE PANIER üî¢
        // Fallback sur 1 si quantit√© non sp√©cifi√©e (s√©curit√©)
        quantity: item.quantity || 1,
      };
    });

    // ==========================================
    // √âTAPE 4 : CALCUL DU TOTAL POUR LES LOGS DE DEBUG
    // ==========================================

    // CALCUL DU MONTANT TOTAL DE LA COMMANDE üßÆ
    // Utilise Array.reduce() pour sommer tous les articles du panier
    // sum = accumulateur (total progressif), item = article courant
    // Formule : prix_unitaire √ó quantit√© pour chaque article
    // ‚ö†Ô∏è Ce calcul est UNIQUEMENT pour les logs - Stripe calculera le vrai total
    const totalAmount = cartItems.reduce(
      (sum, item) => sum + item.price * (item.quantity || 1), // Fallback quantity = 1
      0 // Valeur initiale de l'accumulateur
    );

    // LOG DE DEBUG POUR LE D√âVELOPPEMENT üìä
    // Permet de v√©rifier que le total est coh√©rent avant envoi √† Stripe
    console.log("üí∞ Total commande:", totalAmount, "‚Ç¨");

    // ==========================================
    // √âTAPE 5 : CR√âATION DE LA SESSION STRIPE CHECKOUT
    // ==========================================

    // APPEL API STRIPE POUR CR√âER UNE SESSION DE PAIEMENT üöÄ
    // Cette session g√©n√®re une URL de paiement s√©curis√©e h√©berg√©e par Stripe
    // L'utilisateur sera redirig√© vers cette URL pour finaliser son achat
    const session = await stripe.checkout.sessions.create({
      // ===== CONFIGURATION DE BASE OBLIGATOIRE =====

      // TYPES DE PAIEMENT ACCEPT√âS üí≥
      // ["card"] = uniquement cartes bancaires (Visa, MasterCard, Amex...)
      // Autres options possibles : "ideal", "bancontact", "giropay"...
      payment_method_types: ["card"],

      // ARTICLES CONVERTIS AU FORMAT STRIPE üì¶
      // lineItems cr√©√© √† l'√©tape pr√©c√©dente avec tous les produits du panier
      line_items: lineItems,

      // MODE DE PAIEMENT üîÑ
      // "payment" = paiement unique (vs "subscription" pour abonnements)
      // Adapt√© au mod√®le e-commerce de Soundora (vente d'instruments)
      mode: "payment",

      // ===== INFORMATIONS CLIENT =====

      // EMAIL PR√â-REMPLI DANS LE FORMULAIRE STRIPE üìß
      // Am√©liore l'UX : le client n'a pas √† re-saisir son email
      // Stripe utilisera cet email pour les re√ßus automatiques
      customer_email: userEmail,

      // ===== URLS DE REDIRECTION APR√àS PAIEMENT =====

      // PAGE DE SUCC√àS APR√àS PAIEMENT CONFIRM√â ‚úÖ
      // {CHECKOUT_SESSION_ID} = placeholder remplac√© automatiquement par Stripe
      // Permet √† Angular de r√©cup√©rer les d√©tails de la commande
      success_url: `${process.env.FRONTEND_URL}/order/success?session_id={CHECKOUT_SESSION_ID}`,

      // PAGE DE RETOUR EN CAS D'ANNULATION ‚ùå
      // Ram√®ne l'utilisateur √† son panier pour qu'il puisse r√©essayer
      cancel_url: `${process.env.FRONTEND_URL}/cart`,

      // ===== M√âTADONN√âES POUR LE WEBHOOK ET LE SUIVI =====

      // DONN√âES PERSONNALIS√âES TRANSMISES AU WEBHOOK üìä
      // Ces informations seront disponibles lors du traitement du webhook
      // ‚ö†Ô∏è LIMITATION STRIPE : Les valeurs doivent √™tre des strings uniquement
      metadata: {
        user_email: userEmail, // Email pour cr√©ation commande Supabase
        order_source: "soundora_website", // Source de la commande (vs app mobile)
        cart_total: totalAmount.toString(), // Total calcul√© (conversion string obligatoire)
        items_count: cartItems.length.toString(), // Nombre d'articles (pour validation)
      },

      // ===== PERSONNALISATION DE L'INTERFACE STRIPE =====

      // LOCALISATION EN FRAN√áAIS üá´üá∑
      // Interface Stripe enti√®rement en fran√ßais pour les clients fran√ßais
      locale: "fr",

      // COLLECTE D'ADRESSE DE FACTURATION OBLIGATOIRE üè†
      // N√©cessaire pour la comptabilit√© et la conformit√© fiscale
      billing_address_collection: "required",

      // COLLECTE D'ADRESSE DE LIVRAISON + PAYS AUTORIS√âS üöö
      // Configuration des pays de livraison pour Soundora
      // Limit√© √† l'Europe de l'Ouest pour commencer (logistique simplifi√©e)
      shipping_address_collection: {
        allowed_countries: ["FR", "BE", "CH", "LU", "DE", "ES", "IT"], // Europe de l'Ouest
      },

      // ===== CONFIGURATION AVANC√âE POUR LE SUIVI =====

      // M√âTADONN√âES SUPPL√âMENTAIRES POUR LE PAYMENTINTENT üí°
      // Ces donn√©es sont √©galement accessibles via l'API Stripe
      // Utiles pour les analyses et le support client
      payment_intent_data: {
        metadata: {
          order_source: "soundora", // Identification claire de la source
          total_items: cartItems.length.toString(), // Nombre d'articles pour validation crois√©e
        },
      },
    });

    console.log(" Session Stripe cr√©√©e:", session.id);

    // ==========================================
    // √âTAPE 6 : R√âPONSE DE SUCC√àS AU FRONTEND
    // ==========================================
    // Envoi de l'URL de paiement au frontend Angular
    res.json({
      success: true,
      sessionId: session.id, // ID de session pour le suivi
      checkoutUrl: session.url, // URL vers l'interface de paiement Stripe
      message: "Session de paiement cr√©√©e avec succ√®s",
    });
  } catch (error) {
    console.error(" Erreur Stripe Checkout:", error);

    // ==========================================
    // GESTION D'ERREURS D√âTAILL√âE PAR TYPE STRIPE
    // ==========================================
    let errorMessage = "Erreur lors de la cr√©ation du paiement";

    // Classification des erreurs selon les types Stripe
    if (error.type === "StripeCardError") {
      errorMessage = "Erreur de carte bancaire";
    } else if (error.type === "StripeRateLimitError") {
      errorMessage = "Trop de requ√™tes, veuillez r√©essayer";
    } else if (error.type === "StripeInvalidRequestError") {
      errorMessage = "Requ√™te invalide";
    } else if (error.type === "StripeAPIError") {
      errorMessage = "Erreur temporaire du service de paiement";
    } else if (error.type === "StripeConnectionError") {
      errorMessage = "Erreur de connexion au service de paiement";
    } else if (error.type === "StripeAuthenticationError") {
      errorMessage = "Erreur d'authentification du service de paiement";
    }

    // R√©ponse d'erreur avec d√©tails en mode d√©veloppement
    res.status(500).json({
      success: false,
      error: errorMessage,
      // En d√©veloppement, on affiche le message d'erreur complet
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
};

/**
 * =============================================
 * WEBHOOK STRIPE - CONFIRMATION PAIEMENT
 * =============================================
 *
 * R√îLE : Stripe appelle cette URL quand un paiement est confirm√©
 * CRITIQUE : Permet de cr√©er la commande dans Supabase apr√®s paiement r√©ussi
 *
 * S√âCURIT√â :
 * - V√©rification obligatoire de la signature Stripe
 * - Protection contre les attaques par rejeu
 *
 * √âV√âNEMENTS G√âR√âS :
 * - checkout.session.completed : Paiement r√©ussi
 * - payment_intent.payment_failed : Paiement √©chou√©
 * - checkout.session.expired : Session expir√©e
 *
 * @param {Object} req - Requ√™te Express avec signature Stripe
 * @param {Object} res - R√©ponse Express
 */
/**
 * =============================================
 * WEBHOOK STRIPE - CONFIRMATION PAIEMENT
 * =============================================
 *
 * R√îLE : Stripe appelle cette URL quand un paiement est confirm√©
 * CRITIQUE : Permet de cr√©er la commande dans Supabase apr√®s paiement r√©ussi
 *
 * S√âCURIT√â :
 * - V√©rification obligatoire de la signature Stripe
 * - Protection contre les attaques par rejeu
 *
 * √âV√âNEMENTS G√âR√âS :
 * - checkout.session.completed : Paiement r√©ussi
 * - payment_intent.payment_failed : Paiement √©chou√©
 * - checkout.session.expired : Session expir√©e
 *
 * LOGIQUE DE CR√âATION DE COMMANDE :
 * 1. V√©rification de la signature Stripe (s√©curit√©)
 * 2. Traitement de l'√©v√©nement checkout.session.completed
 * 3. R√©cup√©ration des d√©tails complets de la session
 * 4. Extraction des line_items (articles achet√©s)
 * 5. Cr√©ation de l'enregistrement dans la table 'orders'
 * 6. Cr√©ation des enregistrements dans 'order_items'
 * 7. Logging complet pour debugging
 *
 * @param {Object} req - Requ√™te Express avec signature Stripe
 * @param {Object} res - R√©ponse Express
 */
export const stripeWebhook = async (req, res) => {
  // R√©cup√©ration de la signature Stripe depuis les headers
  const sig = req.headers["stripe-signature"];
  let event;

  try {
    // ==========================================
    // V√âRIFICATION SIGNATURE STRIPE (S√âCURIT√â OBLIGATOIRE)
    // ==========================================
    // Construction et v√©rification de l'√©v√©nement avec la signature
    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    console.error("‚ùå Webhook signature invalide:", err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  console.log("üéâ Webhook Stripe re√ßu:", event.type);

  // ==========================================
  // TRAITEMENT DES √âV√âNEMENTS STRIPE
  // ==========================================
  switch (event.type) {
    case "checkout.session.completed":
      // ===== PAIEMENT CONFIRM√â ET R√âUSSI =====
      const session = event.data.object;
      console.log("üí∞ PAIEMENT CONFIRM√â !");
      console.log("üìß Email client:", session.customer_email);
      console.log("üí∂ Montant:", session.amount_total / 100, "‚Ç¨");
      console.log("üÜî Session ID:", session.id);

      try {
        // ==========================================
        // √âTAPE 1 : R√âCUP√âRATION DES D√âTAILS COMPLETS DE LA SESSION
        // ==========================================
        // Stripe ne donne que les infos de base dans le webhook
        // On doit faire un appel API pour r√©cup√©rer les line_items
        console.log("üîç R√©cup√©ration des d√©tails complets de la session...");

        const detailedSession = await stripe.checkout.sessions.retrieve(
          session.id,
          {
            expand: ["line_items", "line_items.data.price.product"], // Expansion pour r√©cup√©rer tous les d√©tails
          }
        );

        console.log(
          "üì¶ Nombre d'articles:",
          detailedSession.line_items.data.length
        );

        // ==========================================
        // √âTAPE 2 : PR√âPARATION DES DONN√âES POUR LA COMMANDE
        // ==========================================
        const orderData = {
          // === IDENTIFIANTS STRIPE ===
          stripe_session_id: session.id,
          stripe_payment_intent_id: session.payment_intent,

          // === INFORMATIONS CLIENT ===
          user_email: session.customer_email,
          // user_id: null, // TODO: Lier avec l'utilisateur Supabase si connect√©

          // === MONTANTS ===
          total_amount: session.amount_total / 100, // Conversion centimes ‚Üí euros
          currency: session.currency || "eur",

          // === STATUTS ===
          payment_status: "completed", // Paiement confirm√© par Stripe
          order_status: "confirmed", // Commande confirm√©e, en attente de traitement

          // === ADRESSES ===
          // Stripe peut fournir les adresses de facturation et livraison
          billing_address: session.customer_details
            ? {
                name: session.customer_details.name,
                email: session.customer_details.email,
                phone: session.customer_details.phone,
                address: session.customer_details.address,
              }
            : null,

          shipping_address: session.shipping_details
            ? {
                name: session.shipping_details.name,
                address: session.shipping_details.address,
              }
            : null,

          // === M√âTADONN√âES ===
          metadata: {
            ...session.metadata, // M√©tadonn√©es d√©finies lors de la cr√©ation de session
            stripe_session_created: session.created,
            stripe_session_expires: session.expires_at,
            webhook_processed_at: new Date().toISOString(),
            payment_method_types: session.payment_method_types,
          },
        };

        console.log("üìù Donn√©es de commande pr√©par√©es:", {
          email: orderData.user_email,
          total: orderData.total_amount,
          items_count: detailedSession.line_items.data.length,
        });

        // ==========================================
        // √âTAPE 3 : V√âRIFICATION DE L'UNICIT√â DE LA COMMANDE
        // ==========================================
        // S'assurer qu'on ne cr√©e pas deux fois la m√™me commande
        console.log("üîí V√©rification de l'unicit√© de la commande...");

        const { data: existingOrder, error: checkError } = await supabase
          .from("orders")
          .select("id")
          .eq("stripe_session_id", session.id)
          .single();

        if (existingOrder) {
          console.log(
            "‚ö†Ô∏è Commande d√©j√† existante pour cette session:",
            existingOrder.id
          );
          return res.json({ received: true, status: "already_processed" });
        }

        if (checkError && checkError.code !== "PGRST116") {
          // PGRST116 = "row not found", c'est normal
          throw new Error(`Erreur v√©rification unicit√©: ${checkError.message}`);
        }

        // ==========================================
        // √âTAPE 4 : CR√âATION DE LA COMMANDE DANS SUPABASE
        // ==========================================
        console.log("üíæ Cr√©ation de la commande dans Supabase...");

        const { data: newOrder, error: orderError } = await supabase
          .from("orders")
          .insert([orderData])
          .select()
          .single();

        if (orderError) {
          throw new Error(`Erreur cr√©ation commande: ${orderError.message}`);
        }

        console.log("‚úÖ Commande cr√©√©e avec l'ID:", newOrder.id);

        // ==========================================
        // √âTAPE 5 : CR√âATION DES ITEMS DE COMMANDE
        // ==========================================
        console.log("üì¶ Cr√©ation des items de commande...");

        const orderItems = [];

        for (const lineItem of detailedSession.line_items.data) {
          const product = lineItem.price.product;

          const itemData = {
            order_id: newOrder.id,

            // === INFORMATIONS PRODUIT ===
            // Extraction depuis les m√©tadonn√©es Stripe ou nom du produit
            product_id: product.metadata?.product_id
              ? parseInt(product.metadata.product_id)
              : null,
            product_name: product.name,
            product_sku: product.metadata?.sku || null,
            brand_name: product.metadata?.brand || null,
            category_name: product.metadata?.category || null,

            // === PRIX ET QUANTIT√â ===
            unit_price: lineItem.price.unit_amount / 100, // Conversion centimes ‚Üí euros
            quantity: lineItem.quantity,
            total_price: lineItem.amount_total / 100, // Prix total pour cet item

            // === M√âTADONN√âES ===
            product_image_url: product.images?.[0] || null,
            product_metadata: {
              stripe_price_id: lineItem.price.id,
              stripe_product_id: product.id,
              product_description: product.description,
              product_metadata: product.metadata,
            },
          };

          orderItems.push(itemData);

          console.log(
            `  üì± Item: ${itemData.product_name} x${itemData.quantity} = ${itemData.total_price}‚Ç¨`
          );
        }

        // Insertion en batch de tous les items
        const { data: createdItems, error: itemsError } = await supabase
          .from("order_items")
          .insert(orderItems)
          .select();

        if (itemsError) {
          throw new Error(`Erreur cr√©ation items: ${itemsError.message}`);
        }

        console.log("‚úÖ Items cr√©√©s:", createdItems.length);

        // ==========================================
        // √âTAPE 6 : LOGGING FINAL ET CONFIRMATION
        // ==========================================
        console.log("üéä COMMANDE COMPL√àTEMENT TRAIT√âE !");
        console.log("üìä R√©sum√©:", {
          order_id: newOrder.id,
          session_id: session.id,
          email: orderData.user_email,
          total: orderData.total_amount + "‚Ç¨",
          items_count: createdItems.length,
          payment_status: orderData.payment_status,
          order_status: orderData.order_status,
        });

        // TODO: Envoyer email de confirmation au client
        // TODO: Notifier l'√©quipe d'une nouvelle commande
        // TODO: D√©clencher le workflow de pr√©paration
      } catch (error) {
        // ==========================================
        // GESTION D'ERREURS LORS DU TRAITEMENT
        // ==========================================
        console.error("‚ùå ERREUR lors du traitement de la commande:", error);
        console.error("üîç D√©tails session:", {
          session_id: session.id,
          email: session.customer_email,
          amount: session.amount_total / 100,
        });

        // En cas d'erreur, on renvoie quand m√™me 200 pour √©viter que Stripe retente
        // Mais on logue l'erreur pour investigation manuelle
        // TODO: Syst√®me d'alerte pour les erreurs webhook
      }

      break;

    case "payment_intent.payment_failed":
      // ===== PAIEMENT √âCHOU√â =====
      console.log("‚ùå Paiement √©chou√©:", event.data.object.last_payment_error);
      // TODO: Logger l'√©chec, notifier l'administrateur si n√©cessaire
      break;

    case "checkout.session.expired":
      // ===== SESSION EXPIR√âE =====
      console.log("‚è∞ Session expir√©e:", event.data.object.id);
      // TODO : Nettoyer les donn√©es temporaires si n√©cessaire
      break;

    default:
      // ===== √âV√âNEMENT NON G√âR√â =====
      console.log(`‚ÑπÔ∏è √âv√©nement non g√©r√©: ${event.type}`);
  }

  // ==========================================
  // R√âPONSE OBLIGATOIRE POUR STRIPE
  // ==========================================
  // Stripe attend une r√©ponse 200 pour confirmer la r√©ception
  res.json({ received: true });
};

/**
 * =============================================
 * V√âRIFICATION STATUT SESSION
 * =============================================
 *
 * R√îLE : Permet de v√©rifier le statut d'une session Stripe
 * UTILISATION : Page de succ√®s frontend pour afficher les d√©tails
 *
 * @param {Object} req - Requ√™te avec sessionId en param√®tre
 * @param {Object} res - R√©ponse Express
 */
export const getSessionStatus = async (req, res) => {
  try {
    const { sessionId } = req.params;

    // ==========================================
    // R√âCUP√âRATION DE LA SESSION STRIPE
    // ==========================================
    const session = await stripe.checkout.sessions.retrieve(sessionId);

    // R√©ponse avec les informations essentielles
    res.json({
      success: true,
      session: {
        id: session.id,
        payment_status: session.payment_status, // "paid", "unpaid", "no_payment_required"
        customer_email: session.customer_email,
        amount_total: session.amount_total / 100, // Conversion centimes ‚Üí euros
        currency: session.currency,
        created: session.created,
        metadata: session.metadata,
      },
    });
  } catch (error) {
    console.error(" Erreur r√©cup√©ration session:", error);
    res.status(404).json({
      success: false,
      error: "Session non trouv√©e",
    });
  }
};

/**
 * =============================================
 * FONCTION DE TEST - SESSION SIMPLE (10‚Ç¨)
 * =============================================
 *
 * R√îLE : Route pour tester Stripe sans authentification
 * UTILISATION : Tests de d√©veloppement et validation de l'int√©gration
 *
 * @param {Object} req - Requ√™te Express
 * @param {Object} res - R√©ponse Express
 */
export const createTestSessionSimple = async (req, res) => {
  try {
    console.log(" Cr√©ation session TEST SIMPLE...");

    const session = await stripe.checkout.sessions.create({
      payment_method_types: ["card"],
      line_items: [
        {
          price_data: {
            currency: "eur",
            product_data: {
              name: "Test Soundora - Simple",
              description: "Test de paiement simple pour Soundora",
            },
            unit_amount: 1000, // 10‚Ç¨
          },
          quantity: 1,
        },
      ],
      mode: "payment",
      success_url: `${
        process.env.FRONTEND_URL || "http://localhost:4200"
      }/order/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.FRONTEND_URL || "http://localhost:4200"}/cart`,
      metadata: {
        test: "soundora_simple",
        environment: "development",
      },
    });

    console.log("‚úÖ Session TEST SIMPLE cr√©√©e:", session.id);

    res.json({
      success: true,
      sessionId: session.id,
      checkoutUrl: session.url,
      test: "simple",
      amount: "10‚Ç¨",
    });
  } catch (error) {
    console.error("‚ùå Erreur Test Simple:", error.message);
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
};

/**
 * =============================================
 * FONCTION DE TEST - SESSION COMPL√àTE (99‚Ç¨)
 * =============================================
 *
 * R√îLE : Route pour tester Stripe avec m√©tadonn√©es compl√®tes
 * UTILISATION : Tests avanc√©s avec configuration compl√®te
 *
 * @param {Object} req - Requ√™te Express
 * @param {Object} res - R√©ponse Express
 */
export const createTestSessionComplete = async (req, res) => {
  try {
    console.log("üî• Cr√©ation session TEST COMPL√àTE...");

    const session = await stripe.checkout.sessions.create({
      payment_method_types: ["card"],
      line_items: [
        {
          price_data: {
            currency: "eur",
            product_data: {
              name: "üé∏ Guitare Test Soundora",
              description: "Test de paiement complet pour le projet Soundora",
              images: [
                "https://via.placeholder.com/300x300/FF6B6B/FFFFFF?text=üé∏",
              ],
            },
            unit_amount: 9900, // 99‚Ç¨
          },
          quantity: 1,
        },
      ],
      mode: "payment",
      success_url: `http://localhost:4200/order/success?session_id`,
      cancel_url: `http://localhost:4200/cart`,

      // M√©tadonn√©es pour debug
      metadata: {
        test: "soundora_complete",
        environment: "development",
        timestamp: new Date().toISOString(),
      },

      // Configuration avanc√©e
      locale: "fr",
      billing_address_collection: "required",
    });

    console.log(" Session TEST COMPL√àTE cr√©√©e:", session.id);
    console.log(" URL:", session.url);

    res.json({
      success: true,
      sessionId: session.id,
      checkoutUrl: session.url,
      test: "complete",
      amount: "99‚Ç¨",
      debug: {
        created: session.created,
        expires_at: session.expires_at,
        status: session.status,
      },
    });
  } catch (error) {
    console.error(" Erreur Test Complet:", error.message);
    res.status(500).json({
      success: false,
      error: error.message,
      type: error.type || "unknown",
    });
  }
};
